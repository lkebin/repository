package repository

import (
	"fmt"
	"go/types"
	"reflect"
	"regexp"
	"strings"
	"text/template"
)

func GenerateRepositoryImplements(spec *RepositorySpecs) (string, error) {
	implName := fmt.Sprintf("%sImpl", strings.ToLower(spec.Name[:1])+spec.Name[1:])
	var tpl = &strings.Builder{}
	tpl.WriteString("// Code generated by repository_generator.go. DO NOT EDIT.\n")
	tpl.WriteString("package repository\n")
	tpl.WriteString("\n")
	// Imports
	tpl.WriteString("import (\n")
	imports := map[string]any{}
	imports["github.com/jmoiron/sqlx"] = nil
	imports[spec.Pkg.Path()] = nil
	for _, v := range spec.Methods {
		for i := 0; i < v.Signature().Params().Len(); i++ {
			importPath := lookupPkgPath(v.Signature().Params().At(i).Type())
			if importPath != "" {
				imports[importPath] = nil
			}
		}
		for i := 0; i < v.Signature().Results().Len(); i++ {
			importPath := lookupPkgPath(v.Signature().Results().At(i).Type())
			if importPath != "" {
				imports[importPath] = nil
			}
		}
	}
	for k := range imports {
		tpl.WriteString(fmt.Sprintf("\t\"%s\"\n", k))
	}
	tpl.WriteString(")\n")
	tpl.WriteString("\n")

	tpl.WriteString(fmt.Sprintf("type %s struct {\n", implName))
	tpl.WriteString("\tdb sqlx.ExtContext\n")
	tpl.WriteString("}\n")
	tpl.WriteString("\n")

	// New
	tpl.WriteString(fmt.Sprintf("func New%s(db sqlx.ExtContext) %s {\n", spec.Name, fmt.Sprintf("%s.%s", spec.Pkg.Name(), spec.Name)))
	tpl.WriteString(fmt.Sprintf("\treturn &%s{db: db}\n", implName))
	tpl.WriteString("}\n")
	tpl.WriteString("\n")

	modelNamed := lookupNamed(spec.EmbeddedTypeArgs[0])
	if modelNamed == nil {
		return "", fmt.Errorf("parse model error")
	}

	model := getModelFromNamed(modelNamed)
	if model == nil {
		return "", fmt.Errorf("get model from named error")
	}

	// Implements
	for _, v := range spec.Methods {
		fn, err := getFuncImpl(implName, model, v)
		if err != nil {
			return "", err
		}
		tpl.WriteString(fn)
		tpl.WriteString("\n")
	}

	return tpl.String(), nil
}

func parseTuple(params *types.Tuple) string {
	var p = &strings.Builder{}
	for i := 0; i < params.Len(); i++ {
		// Name
		if params.At(i).Name() != "" {
			p.WriteString(params.At(i).Name())
			p.WriteString(" ")
		}

		// Type
		if importPath := lookupPkgPath(params.At(i).Type()); importPath != "" {
			p.WriteString(strings.ReplaceAll(params.At(i).Type().String(), importPath, strings.Split(importPath, "/")[len(strings.Split(importPath, "/"))-1]))
		} else {
			p.WriteString(params.At(i).Type().String())
		}

		// Comma between params
		if i < params.Len()-1 {
			p.WriteString(", ")
		}
	}
	return p.String()
}

var findTpl = `
func (r {{ .Receiver }}) {{ .Name }}({{ Params .Params }}) {{ Results .Results }} {
	{{- if IsReturnSliceModel .Results }}
	var m {{ ResultModel .Results }}
	err := sqlx.SelectContext({{ CtxParam .Params }}, r.db, &m, "{{ SelectClause .SelectColumns }} {{ FromClause .TableName }} {{ WhereClause .WhereColumns }}", {{ VarBinding .Params }})
	if err != nil {
		return nil, err
	}
	return m, nil
	{{- else }}
	var m {{ ResultModel .Results }}
	err := r.db.QueryRowxContext({{ CtxParam .Params }}, "{{ SelectClause .SelectColumns }} {{ FromClause .TableName }} {{ WhereClause .WhereColumns }}", {{ VarBinding .Params }}).StructScan(&m)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &m, nil
	{{- end }}
}`

var deleteTpl = `
func (r {{ .Receiver }}) {{ .Name }}({{ Params .Params }}) {{ Results .Results }} {
	_, err := r.db.ExecContext({{ CtxParam .Params }}, "DELETE {{ FromClause .TableName }} {{ WhereClause .WhereColumns }}", {{ VarBinding .Params }})
	if err != nil {
		return err
	}
	return nil
}`

var createTpl = `
func (r {{ .Receiver }}) {{ .Name }}({{ Params .Params }}) {{ Results .Results }} {
    {{- if IsPkAutoIncrement .Model }}
	result, err := r.db.ExecContext(ctx, "{{ InsertClause .TableName .Model }}", {{ InsertFieldBinding .Params .Model }}))
	if err != nil {
		return nil, err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return nil, err
	}
	return r.Find({{ CtxParam .Params }}, id)
    {{- end }}
}`

var updateTpl = `
func (r {{ .Receiver }}) {{ .Name }}({{ Params .Params }}) {{ Results .Results }} {
	_, err := r.db.ExecContext(ctx, "{{ UpdateClause .TableName .Model }} {{ WhereClause .WhereColumns }}", {{ UpdateFieldBinding .Params .Model }}))
	if err != nil {
		return nil, err
	}

	return nil
}`

type FuncImpl struct {
	Receiver      string
	Name          string
	TableName     string
	Params        *types.Tuple
	Results       *types.Tuple
	Model         *ModelSpecs
	SelectColumns []*Column
	WhereColumns  []*Column
}

type Column struct {
	Name string
}

func getFuncImpl(implName string, model *ModelSpecs, m *types.Func) (string, error) {
	var container = &strings.Builder{}
	fn := FuncImpl{
		Name:      m.Name(),
		Receiver:  fmt.Sprintf("*%s", implName),
		Params:    m.Signature().Params(),
		Results:   m.Signature().Results(),
		TableName: ToSnakeCase(model.Name),
		Model:     model,
	}
	switch m.Name() {
	case "Find":
		pkColumn := lookupPkColumn(model)
		if pkColumn == nil {
			return "", fmt.Errorf("pk column not found")
		}
		fn.WhereColumns = []*Column{{Name: pkColumn.Name}}

		selectColumns := lookupSelectColumns(model)
		fn.SelectColumns = selectColumns

		if err := template.Must(template.New("").Funcs(funcMap()).Parse(findTpl)).Execute(container, fn); err != nil {
			return "", err
		}
	case "Update":
		pkColumn := lookupPkColumn(model)
		if pkColumn == nil {
			return "", fmt.Errorf("pk column not found")
		}
		fn.WhereColumns = []*Column{{Name: pkColumn.Name}}
		if err := template.Must(template.New("").Funcs(funcMap()).Parse(updateTpl)).Execute(container, fn); err != nil {
			return "", err
		}
	case "Create":
		if err := template.Must(template.New("").Funcs(funcMap()).Parse(createTpl)).Execute(container, fn); err != nil {
			return "", err
		}
	case "Delete":
		pkColumn := lookupPkColumn(model)
		if pkColumn == nil {
			return "", fmt.Errorf("pk column not found")
		}
		fn.WhereColumns = []*Column{{Name: pkColumn.Name}}

		if err := template.Must(template.New("").Funcs(funcMap()).Parse(deleteTpl)).Execute(container, fn); err != nil {
			return "", err
		}
	}

	return container.String(), nil
}

func funcMap() template.FuncMap {
	fm := make(template.FuncMap)
	fm["Add"] = func(a, b int) int {
		return a + b
	}

	fm["Params"] = GenParams
	fm["CtxParam"] = GenCtxParam
	fm["Results"] = GenResults
	fm["SelectClause"] = GenSelectClause
	fm["InsertClause"] = GenInsertClause
	fm["UpdateClause"] = GenUpdateClause
	fm["FromClause"] = GenFromClause
	fm["WhereClause"] = GenWhereClause
	fm["VarBinding"] = GenVarBinding
	fm["ResultModel"] = GenResultModel
	fm["IsReturnSliceModel"] = IsReturnSliceModel
	fm["IsPkAutoIncrement"] = IsPkAutoIncrement
	fm["InsertFieldBinding"] = GenInsertFieldBinding
	fm["UpdateFieldBinding"] = GenUpdateFieldBinding
	return fm
}

func GenParams(params *types.Tuple) string {
	return parseTuple(params)
}

func GenCtxParam(params *types.Tuple) string {
	for i := 0; i < params.Len(); i++ {
		if (params.At(i).Type().String()) == "context.Context" {
			return params.At(i).Name()
		}
	}
	return "ctx1"
}

func GenResults(results *types.Tuple) string {
	if results.Len() > 1 {
		return fmt.Sprintf("(%s)", parseTuple(results))
	}
	return parseTuple(results)
}

func GenInsertFieldBinding(params *types.Tuple, model *ModelSpecs) string {
	columns := GenInsertColumns(model)

	var paramName = ""
	for i := 0; i < params.Len(); i++ {
		var p = params.At(i).Type()
		if _, ok := params.At(i).Type().(*types.Pointer); ok {
			p = params.At(i).Type().(*types.Pointer).Elem()
		}

		if p.String() == model.Type.String() {
			paramName = params.At(i).Name()
		}
	}

	var s = &strings.Builder{}
	for i := 0; i < model.Struct.NumFields(); i++ {
		tag := reflect.StructTag(model.Struct.Tag(i))
		cn, _ := ParseTag(tag.Get("db"))
		for _, v := range columns {
			if v.Name == cn {
				s.WriteString(paramName)
				s.WriteString(".")
				s.WriteString(model.Struct.Field(i).Name())
				if i < model.Struct.NumFields()-1 {
					s.WriteString(", ")
				}
			}
		}
	}
	return s.String()
}

func GenUpdateFieldBinding(params *types.Tuple, model *ModelSpecs) string {
	columns := GenUpdateColumns(model)

	var paramName = ""
	for i := 0; i < params.Len(); i++ {
		var p = params.At(i).Type()
		if _, ok := params.At(i).Type().(*types.Pointer); ok {
			p = params.At(i).Type().(*types.Pointer).Elem()
		}

		if p.String() == model.Type.String() {
			paramName = params.At(i).Name()
		}
	}

	var pkFieldName = ""
	var s = &strings.Builder{}
	for i := 0; i < model.Struct.NumFields(); i++ {
		tag := reflect.StructTag(model.Struct.Tag(i))
		cn, opts := ParseTag(tag.Get("db"))
		if opts.Contains("pk") {
			pkFieldName = model.Struct.Field(i).Name()
		}

		for _, v := range columns {
			if v.Name == cn {
				s.WriteString(paramName)
				s.WriteString(".")
				s.WriteString(model.Struct.Field(i).Name())
				if i < model.Struct.NumFields()-1 {
					s.WriteString(", ")
				}
			}
		}
	}

	// where clause binding
	s.WriteString(", ")
	s.WriteString(paramName)
	s.WriteString(".")
	s.WriteString(pkFieldName)

	return s.String()
}

func GenInsertColumns(model *ModelSpecs) []*Column {
	var columns []*Column
	for i := 0; i < model.Struct.NumFields(); i++ {
		tag := reflect.StructTag(model.Struct.Tag(i))
		columnName, opts := ParseTag(tag.Get("db"))
		if opts.Contains("autoincrement") {
			continue
		}
		if opts.Contains("unsafe") {
			continue
		}
		columns = append(columns, &Column{
			Name: columnName,
		})
	}

	return columns
}

func GenUpdateColumns(model *ModelSpecs) []*Column {
	var columns []*Column
	for i := 0; i < model.Struct.NumFields(); i++ {
		tag := reflect.StructTag(model.Struct.Tag(i))
		columnName, opts := ParseTag(tag.Get("db"))
		if opts.Contains("autoincrement") {
			continue
		}
		if opts.Contains("unsafe") {
			continue
		}
		columns = append(columns, &Column{
			Name: columnName,
		})
	}

	return columns
}

func GenInsertClause(tableName string, model *ModelSpecs) string {
	columns := GenInsertColumns(model)

	var s = &strings.Builder{}
	s.WriteString("INSERT INTO ")
	s.WriteString("`")
	s.WriteString(tableName)
	s.WriteString("` (")
	for i, v := range columns {
		s.WriteString("`")
		s.WriteString(v.Name)
		s.WriteString("`")
		if i < len(columns)-1 {
			s.WriteString(", ")
		}
	}
	s.WriteString(") VALUES (")
	for i := range columns {
		s.WriteString("?")
		if i < len(columns)-1 {
			s.WriteString(", ")
		}
	}
	s.WriteString(")")
	return s.String()
}

func GenUpdateClause(tableName string, model *ModelSpecs) string {
	columns := GenUpdateColumns(model)

	var s = &strings.Builder{}
	s.WriteString("UPDATE ")
	s.WriteString("`")
	s.WriteString(tableName)
	s.WriteString("` ")
	s.WriteString("SET ")
	for i, v := range columns {
		s.WriteString("`")
		s.WriteString(v.Name)
		s.WriteString("` = ?")
		if i < len(columns)-1 {
			s.WriteString(", ")
		}
	}
	return s.String()
}

func GenSelectClause(columns []*Column) string {
	var s = &strings.Builder{}
	s.WriteString("SELECT ")
	for i, v := range columns {
		s.WriteString("`")
		s.WriteString(v.Name)
		s.WriteString("`")
		if i < len(columns)-1 {
			s.WriteString(", ")
		}
	}
	return s.String()
}

func GenFromClause(tableName string) string {
	return fmt.Sprintf("FROM `%s`", tableName)
}

func GenWhereClause(columns []*Column) string {
	var s = &strings.Builder{}
	s.WriteString("WHERE ")
	for i, v := range columns {
		s.WriteString("`")
		s.WriteString(v.Name)
		s.WriteString("` = ?")
		if i < len(columns)-1 {
			s.WriteString(" AND ")
		}
	}
	return s.String()
}

func GenVarBinding(params *types.Tuple) string {
	var s = &strings.Builder{}
	// always skip the first params, it's context.Context
	for i := 1; i < params.Len(); i++ {
		s.WriteString(params.At(i).Name())
		if i < params.Len()-1 {
			s.WriteString(", ")
		}
	}
	return s.String()
}

func IsReturnSliceModel(results *types.Tuple) bool {
	return strings.HasPrefix(results.At(0).Type().String(), "[]")
}

func IsPkAutoIncrement(model *ModelSpecs) bool {
	for i := 0; i < model.Struct.NumFields(); i++ {
		tag := reflect.StructTag(model.Struct.Tag(i))
		_, opts := ParseTag(tag.Get("db"))
		if opts.Contains("pk") && opts.Contains("autoincrement") {
			return true
		}
	}
	return false
}

func GenResultModel(results *types.Tuple) string {
	if IsReturnSliceModel(results) {
		if importPath := lookupPkgPath(results.At(0).Type()); importPath != "" {
			return strings.ReplaceAll(results.At(0).Type().String(), importPath, strings.Split(importPath, "/")[len(strings.Split(importPath, "/"))-1])
		}
		return results.At(0).Type().String()
	}

	typ, ok := results.At(0).Type().(*types.Pointer)
	if !ok {
		return results.At(0).Type().String()
	}

	if importPath := lookupPkgPath(typ.Elem()); importPath != "" {
		return strings.ReplaceAll(typ.Elem().String(), importPath, strings.Split(importPath, "/")[len(strings.Split(importPath, "/"))-1])
	}

	return typ.Elem().String()
}

func lookupSelectColumns(model *ModelSpecs) []*Column {
	var columns []*Column
	for i := 0; i < model.Struct.NumFields(); i++ {
		tag := reflect.StructTag(model.Struct.Tag(i))
		columnName, _ := ParseTag(tag.Get("db"))
		columns = append(columns, &Column{
			Name: columnName,
		})
	}
	return columns
}

func lookupPkColumn(model *ModelSpecs) *Column {
	for i := 0; i < model.Struct.NumFields(); i++ {
		tag := reflect.StructTag(model.Struct.Tag(i))
		columnName, opts := ParseTag(tag.Get("db"))
		if opts.Contains("pk") {
			return &Column{
				Name: columnName,
			}
		}
	}
	return nil
}

func getModelFromNamed(n *types.Named) *ModelSpecs {
	specs := ParseModel([]string{n.Obj().Name()}, []string{n.Obj().Pkg().Path()}, []string{})
	if len(specs) > 0 {
		return &specs[0]
	}

	return nil
}

func lookupNamed(typ types.Type) *types.Named {
	switch t := typ.(type) {
	case *types.Pointer:
		return lookupNamed(t.Elem())
	case *types.Slice:
		return lookupNamed(t.Elem())
	case *types.Named:
		return t
	}

	return nil
}

func lookupPkgPath(typ types.Type) string {
	switch t := typ.(type) {
	case *types.Pointer:
		return lookupPkgPath(t.Elem())
	case *types.Slice:
		return lookupPkgPath(t.Elem())
	case *types.Named:
		if pkg := t.Obj().Pkg(); pkg != nil {
			return pkg.Path()
		}
	}
	return ""
}

type TagOptions string

func ParseTag(tag string) (string, TagOptions) {
	if idx := strings.Index(tag, ","); idx != -1 {
		return tag[:idx], TagOptions(tag[idx+1:])
	}
	return tag, TagOptions("")
}

func (t TagOptions) Get(optionName string) string {
	if len(t) == 0 {
		return ""
	}

	s := string(t)
	for s != "" {
		var next string
		i := strings.Index(s, ",")
		if i >= 0 {
			s, next = s[:i], s[i+1:]
		}

		j := strings.Index(s, "=")
		if j >= 0 {
			k, v := s[:j], s[j+1:]
			if k == optionName {
				return v
			}
		}

		s = next
	}

	return ""
}

func (t TagOptions) Contains(optionName string) bool {
	if len(t) == 0 {
		return false
	}
	s := string(t)
	for s != "" {
		var next string
		i := strings.Index(s, ",")
		if i >= 0 {
			s, next = s[:i], s[i+1:]
		}
		if s == optionName {
			return true
		}
		s = next
	}
	return false
}

// ToSnakeCase convert string from camel case to snake case
func ToSnakeCase(camelCase string) string {
	re := regexp.MustCompile(`(.)([A-Z][a-z]+)`)
	s1 := re.ReplaceAllString(camelCase, "${1}_${2}")
	re1 := regexp.MustCompile(`([a-z0-9])([A-Z])`)
	s2 := re1.ReplaceAllString(s1, "${1}_${2}")

	return strings.ToLower(s2)
}
